<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>PostgreSQL 的文件格式 | 不为人知的幻想乡</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel="shortcut icon" href=/favicon.png type=image/x-icon><link rel=icon href=/favicon.png type=image/x-icon><link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:400,700&display=swap&subset=chinese-simplified" rel=stylesheet><link href=/font/FantasqueSansMono-Regular-decl.css rel=stylesheet></head><body><nav><ul class=menu></ul><hr></nav><div class=article-meta><h1><span class=title>PostgreSQL 的文件格式</span></h1><h2 class=date>2020/12/31</h2></div><main><p><a href=https://www.postgresql.org/docs/13/storage-file-layout.html>doc</a></p><p>PostgreSQL 使用 &ldquo;共享硬盘&rdquo; 和 &ldquo;共享内存&rdquo; 的方式在单机上组成集群。尽管文档不断重复 &ldquo;Cluster&rdquo;，PostgreSQL 只能单机运行。</p><p>从文件层面 PostgreSQL 表现如下：</p><table><thead><tr><th>文件名</th><th>作用</th></tr></thead><tbody><tr><td><a href=PG_VERSION>PG_VERSION</a></td><td>版本号</td></tr><tr><td><a href=PG_VERSION>base/NNN/PG_VERSION</a></td><td>版本号</td></tr><tr><td><a href=PageFile>base/NNN/MMM</a></td><td>NNN 库 MMM 表数据</td></tr><tr><td><a href=VisibilityMap>base/NNN/MMM_vm</a></td><td>NNN 库 MMM 表可见块</td></tr><tr><td><a href=FreeSapceMap>base/NNN/MMM_fsm</a></td><td>NNN 库 MMM 表空闲块</td></tr><tr><td><a href=InitFile>base/NNN/MMM_init</a></td><td>NNN 库 MMM 表初始化标记</td></tr><tr><td>current_logfiles</td><td>日志文件当前写入</td></tr><tr><td>global</td><td>pg_global 库里的表类似 base/NNN</td></tr><tr><td>pg_commit_ts</td><td>事务时间戳</td></tr><tr><td>pg_dynshmem</td><td>动态共享内存</td></tr><tr><td>pg_multixact</td><td>共享行锁</td></tr><tr><td>pg_notify</td><td>pg_notify</td></tr><tr><td>pg_logical</td><td>流复制相关，解码状态</td></tr><tr><td>pg_replslot</td><td>流复制相关，复制槽</td></tr><tr><td>pg_serial</td><td>事务相关</td></tr><tr><td>pg_snapshots</td><td>已导出的快照</td></tr><tr><td>pg_stat</td><td>统计信息</td></tr><tr><td>pg_stat_tmp</td><td>临时统计信息</td></tr><tr><td>pg_subtrans</td><td>子事务</td></tr><tr><td>pg_tblspc</td><td>用于 tablespaces 的链接，指向 base/NNN</td></tr><tr><td>pg_twophase</td><td>two phase commmit 相关</td></tr><tr><td><a href=WAL>pg_wal</a></td><td>WAL/xlong 崩溃恢复相关</td></tr><tr><td><a href=XACT>pg_xact</a></td><td>xact/clog 事务信息</td></tr><tr><td>postgresql.auto.conf</td><td>配置文件</td></tr><tr><td>postmaster.opts</td><td>配置文件</td></tr><tr><td>postmaster.pid</td><td>文件锁</td></tr></tbody></table><p>对于 <code>base/NNN</code> 内的文件，文件名为表的 filenode。</p><p>后缀 <code>_vm</code> 为 <a href=VisibilityMap>VisibilityMap</a> 后缀为 <code>_fsm</code> 为 <a href=FreeSapceMap>FreeSapceMap</a> 后缀为 <code>_init</code> 的为 <a href=InitFile>InitFile</a>。</p><p>当一个 PageFile 的大小突破 1G 时就会分裂成多个，命名规则为 <code>NNN.1</code> <code>NNN.2</code>。</p><p>toast 数据与普通表无异。</p><h1 id=pg_version>PG_VERSION</h1><p>一个字符串，对于 PostgreSQL 13 来说是 &ldquo;13\n&rdquo; (0x31330a)</p><h1 id=pagefile>PageFile</h1><p><a href=https://www.postgresql.org/docs/13/storage-page-layout.html>doc</a></p><p>每个 PageFile 存储一堆定长的 Page，长度编译时指定一般是 8KiB。</p><p>每个 Page 结构如下</p><table><thead><tr><th>Item</th><th>Description</th></tr></thead><tbody><tr><td>PageHeaderData</td><td>24byte Header</td></tr><tr><td>ItemIdData</td><td>数组，每个 item 对应 15bit offset + 2bit flag + 15 bit length = 32bit</td></tr><tr><td>Free space</td><td>未分配的数据</td></tr><tr><td>Items</td><td>实际数据</td></tr><tr><td>Special space</td><td>特殊数据，普通表 0bit</td></tr></tbody></table><p>所以 PostgreSQL 理论上支持的最大 Block Size 为 (64Ki - 1 ) Byte，实际上为 64KiB。</p><p>当 Page Size = 8KiB Tuple = 16Byte 时，Page 层面的空间利用率为 79.9%。</p><p>其中 PageHeaderData 如下</p><table><thead><tr><th>Field</th><th>Type</th><th>Length</th><th>Description</th></tr></thead><tbody><tr><td>pd_lsn</td><td>XLogRecPtr</td><td>8 bytes</td><td>LSN: 修改此 Page 的 xlog 记录的下一个 byte</td></tr><tr><td>pd_tli</td><td>uint16</td><td>2 bytes</td><td>最后一次修改的 TimeLineID</td></tr><tr><td>pd_flags</td><td>uint16</td><td>2 bytes</td><td>Flag bits</td></tr><tr><td>pd_lower</td><td>LocationIndex</td><td>2 bytes</td><td>free space 开始的偏移量</td></tr><tr><td>pd_upper</td><td>LocationIndex</td><td>2 bytes</td><td>free space 结束的偏移量</td></tr><tr><td>pd_special</td><td>LocationIndex</td><td>2 bytes</td><td>special space 开始的偏移量</td></tr><tr><td>pd_pagesize_version</td><td>uint16</td><td>2 bytes</td><td>Page size and layout version number information</td></tr><tr><td>pd_prune_xid</td><td>TransactionId</td><td>4 bytes</td><td>最旧的以提交 xid (XMAX)</td></tr></tbody></table><p>其中 pd_lower 为 ItemIdData 分配的开始，pd_upper 为 Items 分配的开始。</p><p><img src=https://www.postgresql.org/docs/13/pagelayout.svg alt="in page alloc"></p><p>每个 Item （名为 HeapTupleHeaderData）格式如下</p><table><thead><tr><th>Field</th><th>Type</th><th>Length</th><th>Description</th></tr></thead><tbody><tr><td>t_xmin</td><td>TransactionId</td><td>4 bytes</td><td>insert XID stamp</td></tr><tr><td>t_xmax</td><td>TransactionId</td><td>4 bytes</td><td>delete XID stamp</td></tr><tr><td>t_cid</td><td>CommandId</td><td>4 bytes</td><td>sql 计数</td></tr><tr><td>t_xvac</td><td>TransactionId</td><td>4 bytes</td><td>VACUUM 的 xid 和 t_cid 是个 union</td></tr><tr><td>t_ctid</td><td>ItemPointerData</td><td>6 bytes</td><td>行 ID</td></tr><tr><td>t_infomask2</td><td>uint16</td><td>2 bytes</td><td>number of attributes, flag</td></tr><tr><td>t_infomask</td><td>uint16</td><td>2 bytes</td><td>flag</td></tr><tr><td>t_hoff</td><td>uint8</td><td>1 byte</td><td>用户数据偏移量</td></tr></tbody></table><p>ctid = Block Number 4 byte + Offset Number 2 byte</p><p>PostgreSQL 为何又存储了一遍 Block ID? + 4 byte</p><p>Header 有 23 byte 大。如果只存两个 i64(16byte) 的话，空间利用率为 41%.</p><p>Timescale 是认真的么?</p><h1 id=visibilitymap>VisibilityMap</h1><p><a href=https://www.postgresql.org/docs/13/storage-vm.html>vm</a></p><p>PostgreSQL 没有说明文件格式，只给了一个<a href=https://www.postgresql.org/docs/13/pgvisibility.html>小工具</a>说明这个文件工作原理。</p><p>一个简单地无 Header 文件，使用一个简单地公式定位</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define HEAPBLK_TO_MAPBLOCK(x) ((x) / HEAPBLOCKS_PER_PAGE)
</span><span style=color:#75715e>#define HEAPBLK_TO_MAPBYTE(x) (((x) % HEAPBLOCKS_PER_PAGE) / HEAPBLOCKS_PER_BYTE)
</span><span style=color:#75715e>#define HEAPBLK_TO_OFFSET(x) (((x) % HEAPBLOCKS_PER_BYTE) * BITS_PER_HEAPBLOCK)
</span></code></pre></div><p>每个 Page 需要至少 2bit 来放 flag</p><ul><li>0b01 VISIBILITYMAP_ALL_VISIBLE Page 可见</li><li>0b10 VISIBILITYMAP_ALL_FROZEN Page 冻结</li></ul><p>不知道可见和冻结是什么意思。</p><p>当这个 page 插入第一个数据时 VISIBILITYMAP_ALL_VISIBLE 被清除</p><p>需要看一下 vacuum lazy 如何实现的。</p><h1 id=freesapcemap>FreeSapceMap</h1><p><a href=https://www.postgresql.org/docs/13/storage-fsm.html>fsm</a></p><p><a href=https://github.com/Sasasu/postgres/tree/master/src/backend/storage/freespace>doc</a></p><p>负责快速找到一个空闲 Page。整体是一个二叉树。</p><p>每个 Page 对应 1 byte 空间，存 255 灰度图。</p><p>每个 FSM Page 是一个定长的二叉堆，大小与 Block Size 相同（包括 Block Header），默认为 8KiB。</p><p>树符合</p><p>$$ value = \max (left, right) $$</p><pre><code>For example:

    4
 4     2
3 4   0 2    &lt;- This level represents heap pages. 叶子节点保存 Block 的序号
</code></pre><p>整个 FSM 文件使用类似的树形结构。使用定高树，高度为 3。</p><p>分配方式为 $$y = n + (n / F + 1) + (n / F^2 + 1) + 1$$</p><p>$F$ 为每个 FMS Page 保存的 Block 数量</p><p>$n$ 为要寻找的 Block 序号</p><p>$y$ 为计算出的 FMS Page 序号</p><p>每次插入分配新空间时需要 3 次 <code>pread</code> 最坏情况一次全局锁的 <code>pwrite</code>，一次 8KiB O(lgN)</p><p>每个数据文件大于 1G 时会分裂，3 层的定高树足够用了。</p><h1 id=initfile>InitFile</h1><p><a href=https://www.postgresql.org/docs/13/storage-init.html>init</a></p><p>只是一个标记，当存在空表时 PostgreSQL crash 用这个标记来恢复。</p><h1 id=wal>WAL</h1><p>WAL 与 XLOG 是一个东西。文档不清晰，要翻代码。</p><p>WAL 固定大小，16MiB 一个文件，文件依旧无头。</p><p>使用的概念上对于一个 <code>TimeLineID</code> 有一个无限长的文件，使用 64bit 的 offset 访问。</p><p>文件名格式为 <code>%08X%08X%08X</code></p><ul><li>TimeLineID 单调递增的 crash-recovery 次数</li><li>SegmantNo 无限长的 offset 的前 32bit</li><li>SegmantNo 无限长的 offset 的后 32bit / 文件大小</li></ul><p>创建或打开文件在 <code>XLogFileInit</code> 中，会循环调用 <code>pwrite</code> 写出一个 <code>16MiB</code> 的文件&mldr;.</p><p>后续的写入和读取均使用 <code>pread</code> <code>pwrite</code>，没有用 <code>smgr</code> 的抽象，也都是不定长的随机 IO。</p><p>文件读取用 <code>XLogReaderRoutine</code> 里的虚函数 <code>XLogPageRead</code> 调用 <code>pread</code> 直接读。</p><p>写入从共享内存进入 <code>XLogBackgroundFlush</code> 里的 <code>XLogWrite</code> 里的 <code>pwrite</code> 直接写入。</p><p><code>XLog</code> 有 <code>Block Header Magic</code>，默认情况同样为 <code>8KiB XLOG_BLCKSZ</code>。</p><p>引入 <code>Block</code> 大概是为了保存完整性。</p><p><code>XLog</code> 格式大致为 <code>[Header [XLog, XLog]]</code> 每个都是不定长的。解析函数为 <code>DecodeXLogRecord</code> 组装函数为 <code>XLogRecordAssemble</code></p><p>有空看完 <a href=https://www.interdb.jp/pg/pgsql09.html>doc</a></p><h1 id=xact>XACT</h1><p>XACT 是事务可见性文件。</p><p>PostgreSQL 中每个事务会有一个 ID，这个 ID 对应定长的事务状态。</p><p>PostgreSQL 可以直接根据 ID 算出 offset 然后访问文件来判断事务是否完成。</p></main><footer><script type=text/x-mathjax-config>
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

!function(e,n,t){for(var o,a,i,c,r,d="https://google-analytics.com/collect",s=n.hostname.split("."),l=e.cookie.match(/(^|; ?)_ga=GA1\.\d\.(\d+\.\d+)(;|$)/),h=l?l[2]:~~(2e9*Math.random())+"."+~~(Date.now()/1e3),g=s.length;g--&&(r="_ga=GA1."+(s.length-g)+"."+h,e.cookie=r+";max-age=63115200;domain="+s.slice(g).join("."),-1==e.cookie.split(/; ?/).indexOf(r)););track=((r,s,l,g,p)=>{if(o={v:1,tid:"UA-171813489-1",aip:1,cid:h,t:r,dr:e.referrer,dt:e.title,dl:n.href,ul:t.language.toLowerCase(),sr:screen.width+"x"+screen.height,vp:innerWidth+"x"+innerHeight},s&&(o.ec=s),l&&(o.ea=l),g&&(o.el=g),p&&(o.ev=p),t.sendBeacon)t.sendBeacon(d,new URLSearchParams(o));else{for(c in a=[],i=new XMLHttpRequest,o)a.push(k+"="+encodeURIComponent(o[c]));i.open("POST",d),i.send(a.join("&"))}}),track("pageview")}(document,location,navigator);
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script></footer></body></html>